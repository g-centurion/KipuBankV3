{
  "compiler": {
    "version": "0.8.30+commit.73712a01"
  },
  "language": "Solidity",
  "output": {
    "abi": [
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "ethPriceFeedAddress_",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "maxWithdrawalAmount_",
            "type": "uint256"
          },
          {
            "internalType": "address",
            "name": "routerAddress_",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "usdcAddress_",
            "type": "address"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
      },
      {
        "inputs": [],
        "type": "error",
        "name": "AccessControlBadConfirmation"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "account",
            "type": "address"
          },
          {
            "internalType": "bytes32",
            "name": "neededRole",
            "type": "bytes32"
          }
        ],
        "type": "error",
        "name": "AccessControlUnauthorizedAccount"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "currentBalanceUsd",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "bankCapUsd",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "attemptedDepositUsd",
            "type": "uint256"
          }
        ],
        "type": "error",
        "name": "Bank__DepositExceedsCap"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "available",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "requested",
            "type": "uint256"
          }
        ],
        "type": "error",
        "name": "Bank__InsufficientBalance"
      },
      {
        "inputs": [],
        "type": "error",
        "name": "Bank__InvalidTokenAddress"
      },
      {
        "inputs": [
          {
            "internalType": "int256",
            "name": "currentPrice",
            "type": "int256"
          },
          {
            "internalType": "int256",
            "name": "previousPrice",
            "type": "int256"
          }
        ],
        "type": "error",
        "name": "Bank__PriceDeviation"
      },
      {
        "inputs": [],
        "type": "error",
        "name": "Bank__SlippageTooHigh"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "updateTime",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "currentTime",
            "type": "uint256"
          }
        ],
        "type": "error",
        "name": "Bank__StalePrice"
      },
      {
        "inputs": [],
        "type": "error",
        "name": "Bank__TokenNotSupported"
      },
      {
        "inputs": [],
        "type": "error",
        "name": "Bank__TransferFailed"
      },
      {
        "inputs": [
          {
            "internalType": "uint256",
            "name": "limit",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "requested",
            "type": "uint256"
          }
        ],
        "type": "error",
        "name": "Bank__WithdrawalExceedsLimit"
      },
      {
        "inputs": [],
        "type": "error",
        "name": "Bank__ZeroAmount"
      },
      {
        "inputs": [],
        "type": "error",
        "name": "EnforcedPause"
      },
      {
        "inputs": [],
        "type": "error",
        "name": "ExpectedPause"
      },
      {
        "inputs": [],
        "type": "error",
        "name": "ReentrancyGuardReentrantCall"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          }
        ],
        "type": "error",
        "name": "SafeERC20FailedOperation"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "user",
            "type": "address",
            "indexed": true
          },
          {
            "internalType": "address",
            "name": "token",
            "type": "address",
            "indexed": true
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256",
            "indexed": false
          }
        ],
        "type": "event",
        "name": "DepositSuccessful",
        "anonymous": false
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "account",
            "type": "address",
            "indexed": false
          }
        ],
        "type": "event",
        "name": "Paused",
        "anonymous": false
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "role",
            "type": "bytes32",
            "indexed": true
          },
          {
            "internalType": "bytes32",
            "name": "previousAdminRole",
            "type": "bytes32",
            "indexed": true
          },
          {
            "internalType": "bytes32",
            "name": "newAdminRole",
            "type": "bytes32",
            "indexed": true
          }
        ],
        "type": "event",
        "name": "RoleAdminChanged",
        "anonymous": false
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "role",
            "type": "bytes32",
            "indexed": true
          },
          {
            "internalType": "address",
            "name": "account",
            "type": "address",
            "indexed": true
          },
          {
            "internalType": "address",
            "name": "sender",
            "type": "address",
            "indexed": true
          }
        ],
        "type": "event",
        "name": "RoleGranted",
        "anonymous": false
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "role",
            "type": "bytes32",
            "indexed": true
          },
          {
            "internalType": "address",
            "name": "account",
            "type": "address",
            "indexed": true
          },
          {
            "internalType": "address",
            "name": "sender",
            "type": "address",
            "indexed": true
          }
        ],
        "type": "event",
        "name": "RoleRevoked",
        "anonymous": false
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "account",
            "type": "address",
            "indexed": false
          }
        ],
        "type": "event",
        "name": "Unpaused",
        "anonymous": false
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "user",
            "type": "address",
            "indexed": true
          },
          {
            "internalType": "address",
            "name": "token",
            "type": "address",
            "indexed": true
          },
          {
            "internalType": "uint256",
            "name": "amount",
            "type": "uint256",
            "indexed": false
          }
        ],
        "type": "event",
        "name": "WithdrawalSuccessful",
        "anonymous": false
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "BANK_CAP_USD",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "CAP_MANAGER_ROLE",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "DEFAULT_ADMIN_ROLE",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "I_ROUTER",
        "outputs": [
          {
            "internalType": "contract IUniswapV2Router02",
            "name": "",
            "type": "address"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "MAX_PRICE_DEVIATION_BPS",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "MAX_WITHDRAWAL_PER_TX",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "PAUSE_MANAGER_ROLE",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "PRICE_FEED_TIMEOUT",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "TOKEN_MANAGER_ROLE",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "USDC_TOKEN",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "WETH_TOKEN",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ]
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "token",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "priceFeed",
            "type": "address"
          },
          {
            "internalType": "uint8",
            "name": "decimals",
            "type": "uint8"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
        "name": "addOrUpdateToken"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          },
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function",
        "name": "balances",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "payable",
        "type": "function",
        "name": "deposit"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "tokenIn",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amountIn",
            "type": "uint256"
          },
          {
            "internalType": "uint256",
            "name": "amountOutMin",
            "type": "uint256"
          },
          {
            "internalType": "uint48",
            "name": "deadline",
            "type": "uint48"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
        "name": "depositAndSwapERC20"
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "getDepositCount",
        "outputs": [
          {
            "internalType": "uint256",
            "name": "",
            "type": "uint256"
          }
        ]
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "role",
            "type": "bytes32"
          }
        ],
        "stateMutability": "view",
        "type": "function",
        "name": "getRoleAdmin",
        "outputs": [
          {
            "internalType": "bytes32",
            "name": "",
            "type": "bytes32"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "getWethAddress",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ]
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "role",
            "type": "bytes32"
          },
          {
            "internalType": "address",
            "name": "account",
            "type": "address"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
        "name": "grantRole"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "role",
            "type": "bytes32"
          },
          {
            "internalType": "address",
            "name": "account",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function",
        "name": "hasRole",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
        "name": "pause"
      },
      {
        "inputs": [],
        "stateMutability": "view",
        "type": "function",
        "name": "paused",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ]
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "role",
            "type": "bytes32"
          },
          {
            "internalType": "address",
            "name": "callerConfirmation",
            "type": "address"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
        "name": "renounceRole"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "role",
            "type": "bytes32"
          },
          {
            "internalType": "address",
            "name": "account",
            "type": "address"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
        "name": "revokeRole"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "newAddress",
            "type": "address"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
        "name": "setEthPriceFeedAddress"
      },
      {
        "inputs": [
          {
            "internalType": "bytes4",
            "name": "interfaceId",
            "type": "bytes4"
          }
        ],
        "stateMutability": "view",
        "type": "function",
        "name": "supportsInterface",
        "outputs": [
          {
            "internalType": "bool",
            "name": "",
            "type": "bool"
          }
        ]
      },
      {
        "inputs": [],
        "stateMutability": "nonpayable",
        "type": "function",
        "name": "unpause"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "tokenAddress",
            "type": "address"
          },
          {
            "internalType": "uint256",
            "name": "amountToWithdraw",
            "type": "uint256"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "function",
        "name": "withdrawToken"
      }
    ],
    "devdoc": {
      "kind": "dev",
      "methods": {
        "addOrUpdateToken(address,address,uint8)": {
          "details": "Restricted to accounts with TOKEN_MANAGER_ROLE.",
          "params": {
            "decimals": "Token decimals.",
            "priceFeed": "Address of the Chainlink price feed for the token.",
            "token": "Address of the token to register."
          }
        },
        "constructor": {
          "details": "Initializes the contract with Chainlink oracle, Uniswap Router, USDC address, and withdrawal limit.",
          "params": {
            "ethPriceFeedAddress_": "Address of the ETH/USD Chainlink oracle.",
            "maxWithdrawalAmount_": "Maximum amount a user can withdraw per transaction.",
            "routerAddress_": "Address of the UniswapV2Router02.",
            "usdcAddress_": "Address of the USDC token."
          }
        },
        "deposit()": {
          "details": "Follows CEI pattern. Checks bank cap using balance before msg.value is added."
        },
        "depositAndSwapERC20(address,uint256,uint256,uint48)": {
          "details": "Follows CEI pattern. Checks bank cap before transferring tokens.",
          "params": {
            "amountIn": "Amount of tokenIn to deposit.",
            "amountOutMin": "Minimum amount of USDC expected (slippage protection).",
            "deadline": "Unix timestamp deadline for the swap.",
            "tokenIn": "Address of the ERC-20 token to deposit."
          }
        },
        "getDepositCount()": {
          "returns": {
            "_0": "depositCount The total number of deposits recorded."
          }
        },
        "getRoleAdmin(bytes32)": {
          "details": "Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."
        },
        "getWethAddress()": {
          "returns": {
            "_0": "weth The canonical WETH token address configured in the router."
          }
        },
        "grantRole(bytes32,address)": {
          "details": "Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."
        },
        "hasRole(bytes32,address)": {
          "details": "Returns `true` if `account` has been granted `role`."
        },
        "paused()": {
          "details": "Returns true if the contract is paused, and false otherwise."
        },
        "renounceRole(bytes32,address)": {
          "details": "Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."
        },
        "revokeRole(bytes32,address)": {
          "details": "Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."
        },
        "supportsInterface(bytes4)": {
          "params": {
            "interfaceId": "Interface identifier (ERC165)."
          },
          "returns": {
            "_0": "True if interface is supported."
          }
        },
        "withdrawToken(address,uint256)": {
          "details": "Follows CEI pattern. Uses low-level call for ETH and SafeERC20 for tokens.",
          "params": {
            "amountToWithdraw": "Amount to withdraw.",
            "tokenAddress": "Address of the token (address(0) for ETH)."
          }
        }
      },
      "version": 1
    },
    "userdoc": {
      "kind": "user",
      "methods": {
        "BANK_CAP_USD()": {
          "notice": "Global deposit cap for the bank in USD (8 decimals)."
        },
        "CAP_MANAGER_ROLE()": {
          "notice": "Role authorized to manage bank caps and oracles."
        },
        "I_ROUTER()": {
          "notice": "Uniswap V2 Router used for token swaps."
        },
        "MAX_PRICE_DEVIATION_BPS()": {
          "notice": "Maximum allowed price deviation (5%)."
        },
        "MAX_WITHDRAWAL_PER_TX()": {
          "notice": "Maximum withdrawal amount per transaction."
        },
        "PAUSE_MANAGER_ROLE()": {
          "notice": "Role authorized to pause/unpause contract operations."
        },
        "PRICE_FEED_TIMEOUT()": {
          "notice": "Maximum time allowed to consider oracle price valid."
        },
        "TOKEN_MANAGER_ROLE()": {
          "notice": "Role authorized to manage the token catalog."
        },
        "USDC_TOKEN()": {
          "notice": "USDC address (main reserve asset of the bank)."
        },
        "WETH_TOKEN()": {
          "notice": "WETH address used in swap routes."
        },
        "addOrUpdateToken(address,address,uint8)": {
          "notice": "Adds or updates a supported token in the bank's token catalog."
        },
        "balances(address,address)": {
          "notice": "Internal balances: user => token => balance."
        },
        "deposit()": {
          "notice": "Deposits ETH to the bank."
        },
        "depositAndSwapERC20(address,uint256,uint256,uint48)": {
          "notice": "Deposits ERC-20 token and automatically swaps it to USDC via Uniswap V2."
        },
        "getDepositCount()": {
          "notice": "Returns total number of successful deposits."
        },
        "getWethAddress()": {
          "notice": "Returns WETH address used for swap routing."
        },
        "pause()": {
          "notice": "Pauses the contract (emergency). Only `PAUSE_MANAGER_ROLE`."
        },
        "setEthPriceFeedAddress(address)": {
          "notice": "Updates the ETH/USD oracle address. Only `CAP_MANAGER_ROLE`."
        },
        "supportsInterface(bytes4)": {
          "notice": "Declares support for AccessControl interfaces."
        },
        "unpause()": {
          "notice": "Unpauses the contract. Only `PAUSE_MANAGER_ROLE`."
        },
        "withdrawToken(address,uint256)": {
          "notice": "Withdraws ETH or USDC from the bank."
        }
      },
      "version": 1
    }
  },
  "settings": {
    "remappings": [
      "@chainlink/contracts-ccip/=lib/chainlink-local/lib/ccip/contracts/",
      "@chainlink/contracts/=lib/chainlink-local/lib/chainlink-brownie-contracts/contracts/",
      "@chainlink/local/src/=lib/chainlink-local/src/",
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@uniswap/v2-periphery/=lib/v2-periphery/",
      "ccip/=lib/chainlink-local/lib/ccip/",
      "chainlink-brownie-contracts/=lib/chainlink-local/lib/chainlink-brownie-contracts/contracts/src/v0.6/vendor/@arbitrum/nitro-contracts/src/",
      "chainlink-local/=lib/chainlink-local/src/",
      "chainlink/=lib/chainlink/",
      "ds-test/=lib/chainlink-local/lib/forge-std/lib/ds-test/src/",
      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
      "forge-std/=lib/forge-std/src/",
      "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "v2-periphery/=lib/v2-periphery/contracts/"
    ],
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "metadata": {
      "bytecodeHash": "ipfs"
    },
    "compilationTarget": {
      "src/KipuBankV3_TP4.sol": "KipuBankV3"
    },
    "evmVersion": "prague",
    "libraries": {}
  },
  "sources": {
    "lib/chainlink-local/lib/chainlink-brownie-contracts/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "keccak256": "0x257a8d28fa83d3d942547c8e129ef465e4b5f3f31171e7be4739a4c98da6b4f0",
      "urls": [
        "bzz-raw://6d39e11b1dc7b9b8ccdabbc9be442ab7cda4a81c748f57e316dcb1bcb4a28bf9",
        "dweb:/ipfs/QmaG6vz6W6iEUBsbHSBob5mdcitYxWjoygxREHpsJHfWrS"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/AccessControl.sol": {
      "keccak256": "0x1a6b4f6b7798ab80929d491b89d5427a9b3338c0fd1acd0ba325f69c6f1646af",
      "urls": [
        "bzz-raw://7bb7f346c12a14dc622bc105ce3c47202fbc89f4b153a28a63bb68193297330c",
        "dweb:/ipfs/QmagwF8P3bUBXwdo159ueEnY9dLSvEWwK24kk2op58egwG"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` from `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/access/IAccessControl.sol": {
      "keccak256": "0xbff9f59c84e5337689161ce7641c0ef8e872d6a7536fbc1f5133f128887aba3c",
      "urls": [
        "bzz-raw://b308f882e796f7b79c9502deacb0a62983035c6f6f4e962b319ba6a1f4a77d3d",
        "dweb:/ipfs/QmaWCW7ahEQqFjwhSUhV7Ae7WhfNvzSpE7DQ58hvEooqPL"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (access/IAccessControl.sol)\n\npragma solidity >=0.8.4;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted to signal this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol": {
      "keccak256": "0xd5ea07362ab630a6a3dee4285a74cf2377044ca2e4be472755ad64d7c5d4b69d",
      "urls": [
        "bzz-raw://da5e832b40fc5c3145d3781e2e5fa60ac2052c9d08af7e300dc8ab80c4343100",
        "dweb:/ipfs/QmTzf7N5ZUdh5raqtzbM11yexiUoLC9z3Ws632MCuycq1d"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {
      "keccak256": "0x0afcb7e740d1537b252cb2676f600465ce6938398569f09ba1b9ca240dde2dfc",
      "urls": [
        "bzz-raw://1c299900ac4ec268d4570ecef0d697a3013cd11a6eb74e295ee3fbc945056037",
        "dweb:/ipfs/Qmab9owJoxcA7vJT5XNayCMaUR1qxqj1NDzzisduwaJMcZ"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {
      "keccak256": "0x1a6221315ce0307746c2c4827c125d821ee796c74a676787762f4778671d4f44",
      "urls": [
        "bzz-raw://1bb2332a7ee26dd0b0de9b7fe266749f54820c99ab6a3bcb6f7e6b751d47ee2d",
        "dweb:/ipfs/QmcRWpaBeCYkhy68PR3B4AgD7asuQk7PwkWxrvJbZcikLF"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\n\npragma solidity >=0.4.16;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
      "keccak256": "0x74ed01eb66b923d0d0cfe3be84604ac04b76482a55f9dd655e1ef4d367f95bc2",
      "urls": [
        "bzz-raw://5282825a626cfe924e504274b864a652b0023591fa66f06a067b25b51ba9b303",
        "dweb:/ipfs/QmeCfPykghhMc81VJTrHTC7sF6CRvaA1FXVq2pJhwYp1dV"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
      "keccak256": "0x304d732678032a9781ae85c8f204c8fba3d3a5e31c02616964e75cfdc5049098",
      "urls": [
        "bzz-raw://299ced486011781dc98f638059678323c03079fefae1482abaa2135b22fa92d0",
        "dweb:/ipfs/QmbZNbcPTBxNvwChavN2kkZZs7xHhYL7mv51KrxMhsMs3j"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        if (!_safeTransfer(token, to, value, true)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        if (!_safeTransferFrom(token, from, to, value, true)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _safeTransfer(token, to, value, false);\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _safeTransferFrom(token, from, to, value, false);\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        if (!_safeApprove(token, spender, value, false)) {\n            if (!_safeApprove(token, spender, 0, true)) revert SafeERC20FailedOperation(address(token));\n            if (!_safeApprove(token, spender, value, true)) revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Oppositely, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity `token.transfer(to, value)` call, relaxing the requirement on the return value: the\n     * return value is optional (but if data is returned, it must not be false).\n     *\n     * @param token The token targeted by the call.\n     * @param to The recipient of the tokens\n     * @param value The amount of token to transfer\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\n     */\n    function _safeTransfer(IERC20 token, address to, uint256 value, bool bubble) private returns (bool success) {\n        bytes4 selector = IERC20.transfer.selector;\n\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(0x00, selector)\n            mstore(0x04, and(to, shr(96, not(0))))\n            mstore(0x24, value)\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\n            // if call success and return is true, all is good.\n            // otherwise (not success or return is not true), we need to perform further checks\n            if iszero(and(success, eq(mload(0x00), 1))) {\n                // if the call was a failure and bubble is enabled, bubble the error\n                if and(iszero(success), bubble) {\n                    returndatacopy(fmp, 0x00, returndatasize())\n                    revert(fmp, returndatasize())\n                }\n                // if the return value is not true, then the call is only successful if:\n                // - the token address has code\n                // - the returndata is empty\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\n            }\n            mstore(0x40, fmp)\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity `token.transferFrom(from, to, value)` call, relaxing the requirement on the return\n     * value: the return value is optional (but if data is returned, it must not be false).\n     *\n     * @param token The token targeted by the call.\n     * @param from The sender of the tokens\n     * @param to The recipient of the tokens\n     * @param value The amount of token to transfer\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\n     */\n    function _safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value,\n        bool bubble\n    ) private returns (bool success) {\n        bytes4 selector = IERC20.transferFrom.selector;\n\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(0x00, selector)\n            mstore(0x04, and(from, shr(96, not(0))))\n            mstore(0x24, and(to, shr(96, not(0))))\n            mstore(0x44, value)\n            success := call(gas(), token, 0, 0x00, 0x64, 0x00, 0x20)\n            // if call success and return is true, all is good.\n            // otherwise (not success or return is not true), we need to perform further checks\n            if iszero(and(success, eq(mload(0x00), 1))) {\n                // if the call was a failure and bubble is enabled, bubble the error\n                if and(iszero(success), bubble) {\n                    returndatacopy(fmp, 0x00, returndatasize())\n                    revert(fmp, returndatasize())\n                }\n                // if the return value is not true, then the call is only successful if:\n                // - the token address has code\n                // - the returndata is empty\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\n            }\n            mstore(0x40, fmp)\n            mstore(0x60, 0)\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity `token.approve(spender, value)` call, relaxing the requirement on the return value:\n     * the return value is optional (but if data is returned, it must not be false).\n     *\n     * @param token The token targeted by the call.\n     * @param spender The spender of the tokens\n     * @param value The amount of token to transfer\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\n     */\n    function _safeApprove(IERC20 token, address spender, uint256 value, bool bubble) private returns (bool success) {\n        bytes4 selector = IERC20.approve.selector;\n\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(0x00, selector)\n            mstore(0x04, and(spender, shr(96, not(0))))\n            mstore(0x24, value)\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\n            // if call success and return is true, all is good.\n            // otherwise (not success or return is not true), we need to perform further checks\n            if iszero(and(success, eq(mload(0x00), 1))) {\n                // if the call was a failure and bubble is enabled, bubble the error\n                if and(iszero(success), bubble) {\n                    returndatacopy(fmp, 0x00, returndatasize())\n                    revert(fmp, returndatasize())\n                }\n                // if the return value is not true, then the call is only successful if:\n                // - the token address has code\n                // - the returndata is empty\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\n            }\n            mstore(0x40, fmp)\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {
      "keccak256": "0x493033a8d1b176a037b2cc6a04dad01a5c157722049bbecf632ca876224dd4b2",
      "urls": [
        "bzz-raw://6a708e8a5bdb1011c2c381c9a5cfd8a9a956d7d0a9dc1bd8bcdaf52f76ef2f12",
        "dweb:/ipfs/Qmax9WHBnVsZP46ZxEMNRQpLQnrdE4dK8LehML1Py8FowF"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/Pausable.sol": {
      "keccak256": "0xdb484371dfbb848cb6f5d70464e9ac9b2900e4164ead76bbce4fef0b44bcc68f",
      "urls": [
        "bzz-raw://f9d6f6f6600a2bec622f699081b58350873b5e63ce05464d17d674a290bb8a7c",
        "dweb:/ipfs/QmQKVzSQY1PM3Bid4QhgVVZyx6B4Jx7XgaQzLKHj38vJz8"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol": {
      "keccak256": "0xa516cbf1c7d15d3517c2d668601ce016c54395bf5171918a14e2686977465f53",
      "urls": [
        "bzz-raw://1e1d079e8edfb58efd23a311e315a4807b01b5d1cf153f8fa2d0608b9dec3e99",
        "dweb:/ipfs/QmTBExeX2SDTkn5xbk5ssbYSx7VqRp9H4Ux1CY4uQM4b9N"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.5.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\nimport {StorageSlot} from \"./StorageSlot.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * IMPORTANT: Deprecated. This storage-based reentrancy guard will be removed and replaced\n * by the {ReentrancyGuardTransient} variant in v6.0.\n *\n * @custom:stateless\n */\nabstract contract ReentrancyGuard {\n    using StorageSlot for bytes32;\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant REENTRANCY_GUARD_STORAGE =\n        0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _reentrancyGuardStorageSlot().getUint256Slot().value = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    /**\n     * @dev A `view` only version of {nonReentrant}. Use to block view functions\n     * from being called, preventing reading from inconsistent contract state.\n     *\n     * CAUTION: This is a \"view\" modifier and does not change the reentrancy\n     * status. Use it only on view functions. For payable or non-payable functions,\n     * use the standard {nonReentrant} modifier instead.\n     */\n    modifier nonReentrantView() {\n        _nonReentrantBeforeView();\n        _;\n    }\n\n    function _nonReentrantBeforeView() private view {\n        if (_reentrancyGuardEntered()) {\n            revert ReentrancyGuardReentrantCall();\n        }\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        _nonReentrantBeforeView();\n\n        // Any calls to nonReentrant after this point will fail\n        _reentrancyGuardStorageSlot().getUint256Slot().value = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyGuardStorageSlot().getUint256Slot().value = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _reentrancyGuardStorageSlot().getUint256Slot().value == ENTERED;\n    }\n\n    function _reentrancyGuardStorageSlot() internal pure virtual returns (bytes32) {\n        return REENTRANCY_GUARD_STORAGE;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/StorageSlot.sol": {
      "keccak256": "0xcf74f855663ce2ae00ed8352666b7935f6cddea2932fdf2c3ecd30a9b1cd0e97",
      "urls": [
        "bzz-raw://9f660b1f351b757dfe01438e59888f31f33ded3afcf5cb5b0d9bf9aa6f320a8b",
        "dweb:/ipfs/QmarDJ5hZEgBtCmmrVzEZWjub9769eD686jmzb2XpSU1cM"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol": {
      "keccak256": "0x2d9dc2fe26180f74c11c13663647d38e259e45f95eb88f57b61d2160b0109d3e",
      "urls": [
        "bzz-raw://81233d1f98060113d9922180bb0f14f8335856fe9f339134b09335e9f678c377",
        "dweb:/ipfs/QmWh6R35SarhAn4z2wH8SU456jJSYL2FgucfTFgbHJJN4E"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {
      "keccak256": "0x8891738ffe910f0cf2da09566928589bf5d63f4524dd734fd9cedbac3274dd5c",
      "urls": [
        "bzz-raw://971f954442df5c2ef5b5ebf1eb245d7105d9fbacc7386ee5c796df1d45b21617",
        "dweb:/ipfs/QmadRjHbkicwqwwh61raUEapaVEtaLMcYbQZWs9gUkgj3u"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "lib/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "keccak256": "0x8a3c5c449d4b7cd76513ed6995f4b86e4a86f222c770f8442f5fc128ce29b4d2",
      "urls": [
        "bzz-raw://1df63ca373dafae3bd0ee7fe70f890a1dc7c45ed869c01de68413e0e97ff9deb",
        "dweb:/ipfs/QmefJgEYGUL8KX7kQKYTrDweF8GB7yjy3nw5Bmqzryg7PG"
      ],
      "license": null,
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "lib/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol": {
      "keccak256": "0x744e30c133bd0f7ca9e7163433cf6d72f45c6bb1508c2c9c02f1a6db796ae59d",
      "urls": [
        "bzz-raw://9bf2f4454ad63d4cff03a0630e787d9e8a9deed80aec89682cd8ad6379d9ef8c",
        "dweb:/ipfs/Qme51hQNR2wpax7ooUadhtqLtXm8ffeVVYyubLkTT4wMCG"
      ],
      "license": null,
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "src/KipuBankV3_TP4.sol": {
      "keccak256": "0x54545fbc0be9774e58152ae5b0fd6f39e271cf002f2fd5041c7498bcd4e3f51b",
      "urls": [
        "bzz-raw://053d5f295c7b715380f0a040015eca832e3246c79e39a661a5676675ea3b9960",
        "dweb:/ipfs/QmRKE9Uo2Gvrq9TnpiZ6vtXf2wujLLNEPkR3MDVzDuahhL"
      ],
      "license": "MIT",
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.30;\n\n/**\n * @title KipuBankV3_TP4\n * @author G-Centurion\n * @notice Educational DeFi bank with ETH/ERC-20 deposits, automatic swap to USDC and limited withdrawals.\n * @dev Integrates Uniswap V2 for swaps and Chainlink for ETH/USD price. Applies CEI, ReentrancyGuard, RBAC and oracle validations.\n */\n\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IUniswapV2Router02} from \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\n\n/// @dev Thrown when the deposited amount exceeds the remaining capacity of the bank in USD.\nerror Bank__DepositExceedsCap(uint256 currentBalanceUsd, uint256 bankCapUsd, uint256 attemptedDepositUsd);\n/// @dev Thrown when the requested withdrawal amount exceeds the per-transaction limit.\nerror Bank__WithdrawalExceedsLimit(uint256 limit, uint256 requested);\n/// @dev Thrown when the user attempts to withdraw more than their available balance.\nerror Bank__InsufficientBalance(uint256 available, uint256 requested);\n/// @dev Thrown when a transfer (ETH or ERC-20) fails.\nerror Bank__TransferFailed();\n/// @dev Thrown when an invalid token address (like address(0)) is used in an ERC-20 context.\nerror Bank__InvalidTokenAddress();\n/// @dev Thrown when a zero amount is provided to a function that expects > 0.\nerror Bank__ZeroAmount();\n/// @dev Thrown when a token is not supported by the bank's token catalog.\nerror Bank__TokenNotSupported();\n/// @dev Thrown if the price obtained after the swap is less than the minimum expected amount.\nerror Bank__SlippageTooHigh();\n/// @dev Thrown if the price obtained from Chainlink is stale (timestamp too old).\nerror Bank__StalePrice(uint256 updateTime, uint256 currentTime);\n/// @dev Thrown if the price deviated too much from expected bounds (circuit breaker).\nerror Bank__PriceDeviation(int256 currentPrice, int256 previousPrice);\n\n\n\n/// @dev Emitted upon a successful ETH or ERC-20 deposit or a successful swap to USDC.\n/// @param user The address of the depositor.\n/// @param token The token address (address(0) for ETH, USDC address for swaps).\n/// @param amount The amount deposited/received.\nevent DepositSuccessful(address indexed user, address indexed token, uint256 amount);\n\n/// @dev Emitted upon a successful ETH or ERC-20 withdrawal.\n/// @param user The address of the user who withdrew.\n/// @param token The token address (address(0) for ETH).\n/// @param amount The amount withdrawn.\nevent WithdrawalSuccessful(address indexed user, address indexed token, uint256 amount);\n\ncontract KipuBankV3 is AccessControl, Pausable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    /// @notice Role authorized to manage bank caps and oracles.\n    bytes32 public constant CAP_MANAGER_ROLE = keccak256(\"CAP_MANAGER_ROLE\");\n    /// @notice Role authorized to pause/unpause contract operations.\n    bytes32 public constant PAUSE_MANAGER_ROLE = keccak256(\"PAUSE_MANAGER_ROLE\");\n    /// @notice Role authorized to manage the token catalog.\n    bytes32 public constant TOKEN_MANAGER_ROLE = keccak256(\"TOKEN_MANAGER_ROLE\");\n\n    /// @notice Global deposit cap for the bank in USD (8 decimals).\n    uint256 public constant BANK_CAP_USD = 1_000_000 * 10 ** 8;\n\n    /// @notice Maximum time allowed to consider oracle price valid.\n    uint256 public constant PRICE_FEED_TIMEOUT = 1 hours;\n\n    /// @notice Maximum allowed price deviation (5%).\n    uint256 public constant MAX_PRICE_DEVIATION_BPS = 500;\n\n    /// @notice Maximum withdrawal amount per transaction.\n    uint256 public immutable MAX_WITHDRAWAL_PER_TX;\n    \n    /// @notice Identifier for native ETH (address(0)).\n    address private constant ETH_TOKEN = address(0);\n\n    /// @notice Uniswap V2 Router used for token swaps.\n    IUniswapV2Router02 public immutable I_ROUTER;\n    /// @notice WETH address used in swap routes.\n    address public immutable WETH_TOKEN;\n    /// @notice USDC address (main reserve asset of the bank).\n    address public immutable USDC_TOKEN;\n\n    /// @notice Chainlink ETH/USD price feed.\n    AggregatorV3Interface private sEthPriceFeed;\n\n    /// @notice Last recorded ETH/USD price (8 decimals) for deviation validation.\n    int256 private lastRecordedPrice;\n\n    /// @notice Configuration for a supported token.\n    /// @dev Includes price feed address, decimals and allowed flag.\n    struct TokenData {\n        address priceFeedAddress;\n        uint8 tokenDecimals;\n        bool isAllowed;\n    }\n\n    /// @notice Catalog of supported tokens with their configuration.\n    mapping(address => TokenData) private sTokenCatalog;\n\n    /// @notice Internal balances: user => token => balance.\n    mapping(address => mapping(address => uint256)) public balances;\n\n    /// @notice Counter of successful deposits.\n    uint256 private _depositCount;\n    /// @notice Counter of successful withdrawals.\n    uint256 private _withdrawalCount;\n    /// @dev Requires amount > 0.\n    modifier nonZero(uint256 amount_) {\n        if (amount_ == 0) revert Bank__ZeroAmount();\n        _;\n    }\n\n    /// @dev Requires supported withdrawal token (ETH or USDC).\n    modifier supportedWithdrawToken(address token_) {\n        if (token_ != ETH_TOKEN && token_ != USDC_TOKEN) revert Bank__TokenNotSupported();\n        _;\n    }\n\n    /// @dev Requires withdrawal respects per-transaction limit.\n    modifier withinWithdrawLimit(uint256 amount_) {\n        if (amount_ > MAX_WITHDRAWAL_PER_TX) revert Bank__WithdrawalExceedsLimit(MAX_WITHDRAWAL_PER_TX, amount_);\n        _;\n    }\n\n    /// @dev Requires allowed deposit token (not ETH, not USDC, and marked as allowed).\n    modifier allowedDepositToken(address token_) {\n        if (token_ == ETH_TOKEN || token_ == USDC_TOKEN) revert Bank__InvalidTokenAddress();\n        if (!sTokenCatalog[token_].isAllowed) revert Bank__TokenNotSupported();\n        _;\n    }\n\n    /**\n     * @dev Initializes the contract with Chainlink oracle, Uniswap Router, USDC address, and withdrawal limit.\n     * @param ethPriceFeedAddress_ Address of the ETH/USD Chainlink oracle.\n     * @param maxWithdrawalAmount_ Maximum amount a user can withdraw per transaction.\n     * @param routerAddress_ Address of the UniswapV2Router02.\n     * @param usdcAddress_ Address of the USDC token.\n     */\n    constructor(\n        address ethPriceFeedAddress_,\n        uint256 maxWithdrawalAmount_,\n        address routerAddress_,\n        address usdcAddress_\n    ) {\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(CAP_MANAGER_ROLE, msg.sender);\n        _grantRole(PAUSE_MANAGER_ROLE, msg.sender);\n        _grantRole(TOKEN_MANAGER_ROLE, msg.sender);\n\n        if (routerAddress_ == address(0) || usdcAddress_ == address(0) || ethPriceFeedAddress_ == address(0)) {\n            revert Bank__InvalidTokenAddress();\n        }\n\n        sEthPriceFeed = AggregatorV3Interface(ethPriceFeedAddress_);\n        MAX_WITHDRAWAL_PER_TX = maxWithdrawalAmount_;\n\n        I_ROUTER = IUniswapV2Router02(routerAddress_);\n        USDC_TOKEN = usdcAddress_;\n        WETH_TOKEN = I_ROUTER.WETH();\n\n        sTokenCatalog[USDC_TOKEN] = TokenData({\n            priceFeedAddress: address(0),\n            tokenDecimals: 6,\n            isAllowed: true\n        });\n        sTokenCatalog[ETH_TOKEN] =\n            TokenData({priceFeedAddress: ethPriceFeedAddress_, tokenDecimals: 18, isAllowed: true});\n    }\n\n    /// @notice Pauses the contract (emergency). Only `PAUSE_MANAGER_ROLE`.\n    function pause() external onlyRole(PAUSE_MANAGER_ROLE) {\n        _pause();\n    }\n\n    /// @notice Unpauses the contract. Only `PAUSE_MANAGER_ROLE`.\n    function unpause() external onlyRole(PAUSE_MANAGER_ROLE) {\n        _unpause();\n    }\n\n    /// @notice Updates the ETH/USD oracle address. Only `CAP_MANAGER_ROLE`.\n    function setEthPriceFeedAddress(address newAddress) external onlyRole(CAP_MANAGER_ROLE) {\n        sEthPriceFeed = AggregatorV3Interface(newAddress);\n    }\n\n    /**\n     * @notice Adds or updates a supported token in the bank's token catalog.\n     * @dev Restricted to accounts with TOKEN_MANAGER_ROLE.\n     * @param token Address of the token to register.\n     * @param priceFeed Address of the Chainlink price feed for the token.\n     * @param decimals Token decimals.\n     */\n    function addOrUpdateToken(address token, address priceFeed, uint8 decimals) external onlyRole(TOKEN_MANAGER_ROLE) {\n        if (token == address(0)) revert Bank__InvalidTokenAddress();\n        sTokenCatalog[token] = TokenData({priceFeedAddress: priceFeed, tokenDecimals: decimals, isAllowed: true});\n    }\n\n    /**\n     * @notice Deposits ERC-20 token and automatically swaps it to USDC via Uniswap V2.\n     * @dev Follows CEI pattern. Checks bank cap before transferring tokens.\n     * @param tokenIn Address of the ERC-20 token to deposit.\n     * @param amountIn Amount of tokenIn to deposit.\n     * @param amountOutMin Minimum amount of USDC expected (slippage protection).\n     * @param deadline Unix timestamp deadline for the swap.\n     */\n    function depositAndSwapERC20(address tokenIn, uint256 amountIn, uint256 amountOutMin, uint48 deadline)\n        external\n        whenNotPaused\n        nonReentrant\n        allowedDepositToken(tokenIn)\n        nonZero(amountIn)\n    {\n        address[] memory path;\n\n        if (tokenIn == WETH_TOKEN) {\n            path = new address[](2);\n            path[0] = WETH_TOKEN;\n            path[1] = USDC_TOKEN;\n        } else {\n            path = new address[](3);\n            path[0] = tokenIn;\n            path[1] = WETH_TOKEN;\n            path[2] = USDC_TOKEN;\n        }\n\n        uint256[] memory amounts = I_ROUTER.getAmountsOut(amountIn, path);\n        uint256 ethPriceUsd = _getEthPriceInUsd();\n        _checkBankCap(amounts[amounts.length - 1], ethPriceUsd);\n\n        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amountIn);\n        IERC20(tokenIn).safeIncreaseAllowance(address(I_ROUTER), amountIn);\n\n        uint256[] memory actualAmounts = I_ROUTER.swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            deadline\n        );\n\n        uint256 usdcReceived = actualAmounts[actualAmounts.length - 1];\n        if (usdcReceived < amountOutMin) revert Bank__SlippageTooHigh();\n\n        unchecked {\n            balances[msg.sender][USDC_TOKEN] += usdcReceived;\n            _depositCount++;\n        }\n\n        emit DepositSuccessful(msg.sender, USDC_TOKEN, usdcReceived);\n    }\n\n    /**\n     * @notice Deposits ETH to the bank.\n     * @dev Follows CEI pattern. Checks bank cap using balance before msg.value is added.\n     */\n    function deposit() external payable whenNotPaused nonReentrant nonZero(msg.value) {\n        uint256 ethPriceUsd = _getEthPriceInUsd();\n        _updateRecordedPrice(int256(ethPriceUsd));\n\n        uint256 pendingDepositUsd = _getUsdValueFromWei(msg.value, ethPriceUsd);\n        _checkEthDepositCap(pendingDepositUsd, ethPriceUsd);\n\n        unchecked {\n            balances[msg.sender][ETH_TOKEN] += msg.value;\n            _depositCount++;\n        }\n\n        emit DepositSuccessful(msg.sender, ETH_TOKEN, msg.value);\n    }\n\n    /**\n     * @notice Withdraws ETH or USDC from the bank.\n     * @dev Follows CEI pattern. Uses low-level call for ETH and SafeERC20 for tokens.\n     * @param tokenAddress Address of the token (address(0) for ETH).\n     * @param amountToWithdraw Amount to withdraw.\n     */\n    function withdrawToken(address tokenAddress, uint256 amountToWithdraw)\n        external\n        whenNotPaused\n        nonReentrant\n        nonZero(amountToWithdraw)\n        supportedWithdrawToken(tokenAddress)\n        withinWithdrawLimit(amountToWithdraw)\n    {\n        uint256 userBalance = balances[msg.sender][tokenAddress];\n        if (userBalance < amountToWithdraw) revert Bank__InsufficientBalance(userBalance, amountToWithdraw);\n\n        unchecked {\n            balances[msg.sender][tokenAddress] = userBalance - amountToWithdraw;\n        }\n        _withdrawalCount++;\n\n        if (tokenAddress == ETH_TOKEN) {\n            (bool success,) = payable(msg.sender).call{value: amountToWithdraw}(\"\");\n            if (!success) revert Bank__TransferFailed();\n        } else {\n            IERC20(tokenAddress).safeTransfer(msg.sender, amountToWithdraw);\n        }\n\n        emit WithdrawalSuccessful(msg.sender, tokenAddress, amountToWithdraw);\n    }\n\n    /**\n     * @dev Calculates total bank value in USD including pending deposit.\n     * @param pendingUsdValue Pending deposit value in USD (8 decimals).\n     * @param ethPriceUsd ETH price in USD (8 decimals).\n     * @return Total USD value.\n     */\n    function _getBankTotalUsdValue(uint256 pendingUsdValue, uint256 ethPriceUsd) private view returns (uint256) {\n        uint256 ethBalance = address(this).balance;\n        uint256 currentEthUsdValue = _getUsdValueFromWei(ethBalance, ethPriceUsd);\n        uint256 usdcBalance = IERC20(USDC_TOKEN).balanceOf(address(this));\n        uint256 currentUsdcUsdValue = _getUsdValueFromUsdc(usdcBalance);\n        return currentEthUsdValue + currentUsdcUsdValue + pendingUsdValue;\n    }\n\n    /**\n     * @dev Checks if adding pending deposit would exceed bank cap.\n     * @param pendingUsdValue Pending deposit value in USD (8 decimals).\n     * @param ethPriceUsd ETH price in USD (8 decimals).\n     */\n    function _checkBankCap(uint256 pendingUsdValue, uint256 ethPriceUsd) private view {\n        uint256 totalUsdValueIfAccepted = _getBankTotalUsdValue(pendingUsdValue, ethPriceUsd);\n        if (totalUsdValueIfAccepted > BANK_CAP_USD) {\n            uint256 currentUsdBalance = _getBankTotalUsdValue(0, ethPriceUsd);\n            revert Bank__DepositExceedsCap(currentUsdBalance, BANK_CAP_USD, pendingUsdValue);\n        }\n    }\n\n    /**\n     * @dev Checks ETH deposit cap accounting for msg.value already in balance.\n     * @param pendingUsdValue Pending ETH deposit value in USD (8 decimals).\n     * @param ethPriceUsd ETH price in USD (8 decimals).\n     */\n    function _checkEthDepositCap(uint256 pendingUsdValue, uint256 ethPriceUsd) private view {\n        uint256 preEthBalance = address(this).balance - msg.value;\n        uint256 preEthUsd = _getUsdValueFromWei(preEthBalance, ethPriceUsd);\n        uint256 usdcBalance = IERC20(USDC_TOKEN).balanceOf(address(this));\n        uint256 preUsdcUsd = _getUsdValueFromUsdc(usdcBalance);\n        uint256 totalIfAccepted = preEthUsd + preUsdcUsd + pendingUsdValue;\n        if (totalIfAccepted > BANK_CAP_USD) {\n            uint256 currentUsdBalance = preEthUsd + preUsdcUsd;\n            revert Bank__DepositExceedsCap(currentUsdBalance, BANK_CAP_USD, pendingUsdValue);\n        }\n    }\n\n    /**\n     * @dev Retrieves latest ETH/USD price from Chainlink oracle with validation.\n     * @return ETH price in USD (8 decimals).\n     */\n    function _getEthPriceInUsd() internal view returns (uint256) {\n        (, int256 price,, uint256 updatedAt,) = sEthPriceFeed.latestRoundData();\n\n        if (price <= 0) revert Bank__TransferFailed();\n\n        uint256 timeSinceUpdate = block.timestamp - updatedAt;\n        if (timeSinceUpdate > PRICE_FEED_TIMEOUT) {\n            revert Bank__StalePrice(updatedAt, block.timestamp);\n        }\n\n        uint256 uintPrice = uint256(price);\n\n        if (lastRecordedPrice > 0) {\n            int256 priceDiff = price - lastRecordedPrice;\n            int256 maxAllowedDiff = (lastRecordedPrice * int256(MAX_PRICE_DEVIATION_BPS)) / 10000;\n\n            if (priceDiff > maxAllowedDiff || priceDiff < -maxAllowedDiff) {\n                revert Bank__PriceDeviation(price, lastRecordedPrice);\n            }\n        }\n\n        return uintPrice;\n    }\n\n    /**\n     * @dev Updates last recorded price for deviation checking.\n     * @param newPrice Latest accepted ETH/USD price (8 decimals).\n     */\n    function _updateRecordedPrice(int256 newPrice) internal {\n        lastRecordedPrice = newPrice;\n    }\n\n    /**\n     * @dev Converts ETH amount to USD value.\n     * @param ethAmount Amount in Wei (18 decimals).\n     * @param ethPriceUsd ETH price in USD (8 decimals).\n     * @return USD value (8 decimals).\n     */\n    function _getUsdValueFromWei(uint256 ethAmount, uint256 ethPriceUsd) private pure returns (uint256) {\n        return (ethAmount * ethPriceUsd) / 10 ** 18;\n    }\n\n    /**\n     * @dev Converts USDC amount to USD value.\n     * @param usdcAmount Amount in USDC (6 decimals).\n     * @return USD value (8 decimals).\n     */\n    function _getUsdValueFromUsdc(uint256 usdcAmount) private pure returns (uint256) {\n        return usdcAmount * 10 ** 2;\n    }\n\n    /**\n     * @notice Returns total number of successful deposits.\n     * @return depositCount The total number of deposits recorded.\n     */\n    function getDepositCount() external view returns (uint256) {\n        return _depositCount;\n    }\n\n    /**\n     * @notice Returns WETH address used for swap routing.\n     * @return weth The canonical WETH token address configured in the router.\n     */\n    function getWethAddress() external view returns (address) {\n        return WETH_TOKEN;\n    }\n\n    /**\n     * @notice Declares support for AccessControl interfaces.\n     * @param interfaceId Interface identifier (ERC165).\n     * @return True if interface is supported.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControl) returns (bool) {\n        return AccessControl.supportsInterface(interfaceId);\n    }\n}\n"
    }
  },
  "version": 1
}